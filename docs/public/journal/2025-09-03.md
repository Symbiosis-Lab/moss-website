---
topics:
  - Plugin Architecture
  - System Design
  - Identity Shift
---

# The Plugin Architecture Question

## The Question That Changed Everything

"We want to maintain a minimal core and treat everything else as plugins. So, it seems that each existing SSGs should be packaged as a plugin. How does this change our architectural design?"

This question triggered a fundamental shift in how we think about moss—from a static site generator with plugin support to a **plugin orchestration platform**.

## The New Architecture

### Minimal Core (~5MB)

moss core handles only essential orchestration:
- Content analysis and folder structure detection  
- Plugin discovery, loading, and management
- File system abstraction and virtual structure mapping
- Local preview server and deployment coordination

Everything else—SSGs, themes, publishers, analytics—becomes a plugin.

### SSGs as Plugins

Instead of embedding Jekyll and Hugo logic in the core:

**Default Minimal Plugin**: Bundled lightweight SSG for immediate value  
**Jekyll Plugin**: Access to Ruby ecosystem and 300+ themes  
**Hugo Plugin**: Go-based performance with extensive theme library  
**Zola Plugin**: Rust-native, minimal footprint

Each plugin runs in process isolation. Plugins can crash without affecting the core system. JSON-RPC provides language-agnostic communication.

### Plugin System Benefits

This approach provides several advantages:

**Security**: Process isolation prevents plugin failures from crashing the core  
**Flexibility**: Write plugins in any language that can handle JSON-RPC  
**Stability**: Plugin crashes are contained and recoverable  
**Extensibility**: Community can add new SSGs without core changes

## Why This Architecture Matters

This transforms moss from ecosystem competitor to **ecosystem enabler**:

**Theme Access**: 1000+ themes across all major SSGs become available  
**Zero Learning Curve**: Users keep their workflows, moss handles integration  
**Progressive Enhancement**: Start simple, add capabilities as needed  
**Ecosystem Growth**: Strengthen existing tools instead of fragmenting the market  
**Universal Features**: Social and publishing features work with any SSG

## The Homebrew Analogy

This strengthens our "Homebrew for static sites" vision:

- **Core = Homebrew**: Package management and orchestration
- **Plugins = Formulae**: Individual packages installed on-demand
- **Theme Marketplace**: Visual selection drives technical choices
- **Auto-installation**: Complexity handled automatically

Users point to what they want; moss handles the technical details.

## Implementation Strategy

**Phase 1**: Extract current SSG as first plugin to validate architecture  
**Phase 2**: Add Jekyll plugin to test multi-language communication  
**Phase 3**: Build theme marketplace with visual selection  
**Phase 4**: Add publisher plugins for major hosting platforms

Each phase builds on proven foundations.

## Technical Architecture

```rust
// Plugin interface
pub trait Plugin: Send + Sync {
    fn manifest(&self) -> &PluginManifest;
    fn can_handle(&self, request: &PluginRequest) -> bool;
    fn execute(&self, request: PluginRequest) -> Result<PluginResponse>;
}

// SSG-specific extensions
pub trait SsgPlugin: Plugin {
    fn required_structure(&self) -> FolderMapping;
    fn supported_themes(&self) -> Vec<ThemeInfo>;
    fn build_site(&self, config: &BuildConfig) -> Result<SiteResult>;
}
```

Process isolation ensures stability. Sandboxed execution limits filesystem and network access to declared needs. Manifest systems define plugin capabilities and dependencies.

## The Identity Shift

This isn't just architectural change—it's identity clarification. moss isn't another static site generator. moss is a **static site orchestration platform** that includes a minimal SSG as its first plugin.

We're building infrastructure that enables the entire ecosystem rather than competing with individual tools. Like moss in nature, we grow in overlooked spaces—bridging the gap between "I want to publish" and "I need to learn Jekyll."

## Cognitive Load Connection

Research on cognitive load validates this approach. Human working memory is limited to ~4 "chunks" of information. Reducing cognitive load isn't just preference—it's psychological necessity.

Instagram scaled to 14 million users with just 3 engineers by maintaining architectural simplicity. Our plugin approach follows the same pattern: simple interfaces hiding complex implementation.

## Philosophy Implementation

**"Infrastructure that does almost nothing, beautifully"**: Small core enables unlimited plugin capability

**"Patient growth"**: Enable existing tools rather than replace them

**"Not a platform"**: Coordinate platforms rather than create another one

The plugin architecture reveals our purpose as ecosystem orchestrators, not competitors.

## References

- [Plugin Architecture Documentation](../internal/development/plugin-architecture.md) - Technical implementation details
- [Cognitive Load in Software Development](https://minds.md/zakirullin/cognitive) - Research backing architectural simplicity

---

*The right architectural question doesn't just change your code—it reveals what you're actually building.*