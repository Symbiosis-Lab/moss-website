---
topics:
  - Rust Module Conventions
  - macOS Development Constraints
  - Code Organization
  - Developer Experience
---

# Evolution and Acceptance

## The Great Reorganization

Today we migrated from ancient Rust patterns to modern conventions—a journey that felt like archaeological renovation.

The project had grown organically: a 1,667-line `compile.rs` file that had accumulated everything from folder scanning to HTML generation. Multiple `mod.rs` files scattered throughout, each a identical name in the IDE's tab bar.

Following the Rust 2018+ module convention, we:
- Split `compile.rs` into domain-focused modules: `analysis.rs`, `generator.rs`, `server.rs`
- Moved `compile/mod.rs` → `compile.rs` (parent level)
- Moved `preview/mod.rs` → `preview.rs` (parent level)
- Eliminated every `mod.rs` file in the codebase

The result? A net reduction from 2,557 lines to 2,003 lines of cleaner, more focused code. All 34 tests still pass. The IDE now shows meaningful file names in tabs instead of `mod.rs (compile)` and `mod.rs (preview)`.

**Small changes, profound ergonomics.**

## The Icon That Wouldn't Cooperate

Then came the dock icon mystery.

User feedback: "The dock icon shows a generic executable instead of the moss icon."

This seemed straightforward—just set the application icon programmatically. We tried multiple approaches:

**Attempt 1**: `NSApplication::setApplicationIconImage` at startup using cocoa crate  
**Attempt 2**: Adding `CFBundleIconFile` to Info.plist  
**Attempt 3**: Runtime icon setting with verification  
**Attempt 4**: Dock tile manipulation

Each approach compiled successfully. Each logged "✅ Application icon set". Each failed to change the visible dock icon in development mode.

The research revealed the fundamental constraint: **macOS treats terminal-launched executables differently than proper app bundles.** In development mode (`cargo run`, `npm run tauri dev`), we're launching a raw executable that inherits the terminal's context.

The production app works perfectly—`/Applications/moss.app` shows the correct icon. But development mode will always show the generic executable icon, regardless of our programmatic efforts.

## The Art of Surrender

Sometimes the most valuable lesson is learning what not to fight.

We could have spent days building elaborate workarounds: generating development-time app bundles, complex build scripts, or runtime bundle manipulation. Instead, we chose acceptance.

**The trade-off was clear:**
- **Gained**: Hours of development time for features that matter
- **Lost**: Perfect icon consistency in development mode
- **Learned**: System constraints are teachers, not enemies

## Developer Happiness Compounds

The module reorganization delivered immediate ergonomic improvements:
- IDE tabs now show meaningful names
- Code navigation is intuitive (`analysis.rs` contains analysis logic)
- New contributors can understand the architecture at a glance
- Testing and maintenance become more focused

These aren't dramatic features users will notice, but they're the foundation that enables everything else. **Developer experience is infrastructure.**

## Looking Forward

The icon investigation taught us to distinguish between problems worth solving and constraints worth accepting. Some battles improve the product; others just consume time.

Future icon work will focus on production polish: ensuring proper icons in installers, system notifications, and file associations. The development mode quirk becomes documented context, not a blocking issue.

**The best solutions often involve changing what you optimize for.**

## Key Insights

**Module organization is architecture made visible.** Clear file names and focused responsibilities make the codebase welcoming to future developers.

**System constraints teach humility.** Not every problem is ours to solve. Sometimes the system knows best, and our job is to work within its reality.

**Developer ergonomics compound.** Small improvements to daily workflows accumulate into major productivity gains over time.

**Production matters more than development aesthetics.** Users never see our development environment. Optimizing for their experience trumps perfect development consistency.

## References

- [Rust Module System](https://doc.rust-lang.org/reference/items/modules.html) - rustc 1.30+ conventions
- [macOS Application Bundles](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html) - Understanding .app structure
- [Tauri Issue #2985](https://github.com/tauri-apps/tauri/issues/2985) - macOS dock icon limitations

---

*The best refactoring feels inevitable in retrospect. The best debugging teaches us when to stop.*