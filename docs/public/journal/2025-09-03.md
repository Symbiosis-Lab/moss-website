# The Plugin Architecture Breakthrough

## The Question That Changed Everything

"We want to maintain a minimal core and treat everything else as plugins. So, it seems that each existing SSGs should be packaged as a plugin. How does this change our architectural design?"

This simple question triggered a fundamental shift in how we think about moss—from a static site generator with plugin support to a **plugin orchestration platform**.

## What We Realized

### The True Minimal Core

moss core should be irreducibly small—around 5MB—handling only:
- Content analysis and folder structure detection  
- Plugin discovery, loading, and orchestration
- File system abstraction and virtual structure mapping
- Local preview server and deployment coordination

Everything else—SSGs, themes, publishers, analytics—becomes a plugin.

### SSGs as First-Class Plugins

Instead of embedding Jekyll and Hugo logic in the core, each SSG becomes a standalone plugin:
- **Default Minimal Plugin**: Bundled lightweight SSG for instant value
- **Jekyll Plugin**: Ruby ecosystem + 300+ themes
- **Hugo Plugin**: High performance Go-based SSG  
- **Zola Plugin**: Rust-native, minimal footprint

### The Homebrew Analogy Strengthens

This architectural shift actually **strengthens** our "Homebrew for static sites" vision:
- **Core = Homebrew itself**: Package management and orchestration
- **Plugins = Formulae**: Individual packages users install on-demand
- **Theme Marketplace = Cask Room**: Visual selection driving technical choices
- **Auto-installation = Dependency Resolution**: moss handles complexity

## Technical Architecture

### Plugin Communication

**JSON-RPC over subprocess**: Language-agnostic, process-isolated, secure
- Plugins crash independently without affecting core
- Write plugins in any language (Rust, Ruby, Go, Python)
- Compatible with existing SSG binaries
- Sandboxed execution environment

### Plugin Interface

```rust
pub trait Plugin: Send + Sync {
    fn manifest(&self) -> &PluginManifest;
    fn can_handle(&self, request: &PluginRequest) -> bool;
    fn execute(&self, request: PluginRequest) -> Result<PluginResponse>;
}

pub trait SsgPlugin: Plugin {
    fn required_structure(&self) -> FolderMapping;
    fn supported_themes(&self) -> Vec<ThemeInfo>;
    fn build_site(&self, config: &BuildConfig) -> Result<SiteResult>;
}
```

### Directory Structure

```
~/.moss/
├── plugins/           # User-installed plugins
│   ├── jekyll/        # Plugin with manifest + executable
│   └── hugo/          # Another plugin
├── cache/             # Downloaded binaries and themes
└── config.toml        # User preferences
```

## The User Journey

### Progressive Enhancement
1. **New user**: Right-clicks folder → Default minimal plugin builds instantly
2. **Theme discovery**: Browses themes → Auto-selects required SSG plugin  
3. **Advanced user**: Installs specific plugins for specialized needs

### Zero Configuration Maintained
- Default minimal plugin provides beautiful results immediately
- Plugins auto-install when needed (with user consent)
- User folder structure preserved across all plugins

## Implementation Strategy

### Phase 1: Infrastructure Foundation
- Extract current minimal SSG as first plugin
- Implement plugin loading and JSON-RPC communication
- Create plugin manifest specification
- Add security sandbox

### Phase 2: Core SSG Plugins  
- Convert Jekyll integration to standalone plugin
- Convert Hugo integration to standalone plugin
- Build theme plugin system
- Create plugin marketplace foundation

### Phase 3: Ecosystem Growth
- Third-party plugin development tools
- Remote plugin discovery and installation
- Community contribution guidelines
- Plugin monetization framework

## Why This Matters

### For Users
- **Instant value**: Default plugin works immediately
- **Unlimited growth**: Add capabilities without core bloat
- **Security**: Process isolation prevents plugin crashes affecting core
- **Choice**: Pick exactly the tools you need

### For Developers
- **Language freedom**: Write plugins in any language
- **Clear APIs**: Well-defined interfaces for plugin development
- **Independent deployment**: Update plugins without core releases
- **Community ecosystem**: Enable third-party contributions

### For moss
- **Sustainable architecture**: Core stays small and maintainable
- **Ecosystem growth**: Community can extend capabilities
- **Platform differentiation**: Orchestration layer, not another SSG
- **Revenue model**: Plugin marketplace enables monetization

## The Deeper Insight

This isn't just an architectural change—it's an **identity clarification**. moss isn't a static site generator that supports plugins. moss is a **static site orchestration platform** that happens to include a minimal SSG as its first plugin.

We're building infrastructure that enables the entire ecosystem, not competing with individual tools. Like moss in nature, we grow in the overlooked spaces—the gap between "I want to publish" and "I need to learn Jekyll"—creating conditions for the whole forest to flourish.

## Next Steps

1. **Document plugin API**: Create comprehensive plugin development guide
2. **Extract minimal SSG**: Current compilation logic becomes first plugin  
3. **Implement JSON-RPC**: Plugin communication protocol
4. **Security model**: Process sandboxing and permission system
5. **Plugin marketplace**: Discovery and installation system

The plugin architecture transforms moss from a tool into a platform. Not just another static site generator, but the orchestration layer that makes the entire ecosystem accessible.

---

**Technical Reference**: [Plugin Architecture Documentation](../internal/development/plugin-architecture.md)