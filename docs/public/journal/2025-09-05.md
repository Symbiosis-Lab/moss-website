---
topics:
  - CSS Syntax Highlighting
  - WebView Debugging
  - Build Dependencies
  - Visual Testing
---

# The Same URL, Different Content Mystery

## The Color Problem

Added syntax highlighting with bright blue colors. User feedback was immediate: "The color is too bright and contrast too big."

This wasn't just aesthetic feedbackâ€”it highlighted a design principle. Moss exists to create comfortable reading experiences. Bright syntax colors might look good in isolation, but they violated the overall philosophy of warm, paper-like comfort.

Switched to earth tones: moss green for systems, warm gray for web languages, muted brown for configuration. Colors that enhance readability without demanding attention.

## The Impossible Bug

Then we hit something strange.

Browser at `localhost:8080`: showed correct warm colors  
Preview window at `localhost:8080`: showed old bright colors

Same server, same URL, different content.

Timeline:
- 9:26 AM: Compiled binary, started moss
- 9:27 AM: Opened preview window showing old colors  
- 9:28 AM: New CSS written to disk
- Browser: correct colors
- Preview window: wrong colors

Both should be loading from the same localhost server.

## Investigation

Checked WebView cache directories:
- `~/Library/WebKit/com.moss.publisher/`  
- `~/Library/Caches/com.moss.publisher/WebKit/`

Found mostly empty directories, just salt files from August. No cached CSS or HTML. The preview window code confirmed it loads from localhost:8080, not embedded resources.

Yet somehow the same URL served different content to different contexts.

## What Fixed It

Full rebuild resolved the issue:
1. Kill all moss processes
2. `cargo clean && cargo build`
3. `npm run dev` with new binary
4. Preview window shows correct colors

But we still don't know why this worked. Both contexts should load identical content from localhost.

**Root cause remains unknown.**

## The Build System Issue

Meanwhile, discovered a Cargo dependency tracking problem. CSS is embedded at compile time via `include_str!`, but Cargo's dependency tracking for this is inconsistent across platforms.

**Solution**: Explicit dependency tracking in `build.rs`:
```rust
println!("cargo:rerun-if-changed=src/assets/default.css");
```

This ensures reliable rebuilds when CSS assets change, preventing stale content in preview windows.

## The Testing Gap

This debugging revealed a fundamental blind spot: **we test what we generate, not what users see.**

Current tests validate HTML structure, content presence, CSS path resolution. But we don't test visual rendering, responsive behavior, or JavaScript functionality.

We're testing the recipe, not whether the meal tastes good.

### Visual Testing Strategy

**Phase 1**: Extend HTML tests with semantic structure validation (`<h1>`, `class="main-nav"`, `aria-label`)

**Phase 2**: Playwright screenshots at localhost:8080 for visual regression testing

**Phase 3**: Full Tauri preview window E2E testing via WebDriver

**Phase 4**: Cross-platform visual baselines (macOS, Windows, Linux)

The goal: catch visual bugs before users see them.

## Key Insights

**Build systems need explicit dependencies.** Implicit promises like `include_str!` dependency tracking can fail across platforms.

**Visual testing is essential.** Beautiful defaults must be verified, not assumed.

**Some mysteries teach more than solutions.** We fixed the symptoms but learned to be humble about what we don't understand.

When the same URL shows different content in different contexts, you're seeing something fundamental about software complexity. Document what you know, admit what you don't, and keep investigating.

## References

- [Cargo Issue #1510](https://github.com/rust-lang/cargo/issues/1510) - include_str! dependency tracking inconsistencies
- [CSS :has() selector](https://developer.mozilla.org/en-US/docs/Web/CSS/:has) - Modern CSS for language targeting
- [Tauri WebView debugging](https://v2.tauri.app/develop/debug/) - Official debugging docs

---

*The hardest bugs to fix are the ones you can't reproduce. Sometimes the most honest documentation admits what remains unknown.*