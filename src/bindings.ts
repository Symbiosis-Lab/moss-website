
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Tauri command for folder compilation with real-time progress channel.
 * 
 * This function handles GUI compilation with real-time progress updates sent
 * through a Tauri channel. It performs folder scanning, site generation, and
 * preview server startup with detailed progress information.
 * 
 * # Arguments
 * * `app` - Tauri app handle for preview URL communication
 * * `folder_path` - Absolute path to the folder containing website content
 * * `auto_serve` - Whether to automatically start preview server after compilation (default: false)
 * * `on_progress` - Channel for real-time progress updates
 * 
 * # Returns
 * * `Ok(String)` - Success message with compilation summary (and server info if started)
 * * `Err(String)` - Error message describing what went wrong
 */
async compileFolder(folderPath: string, autoServe: boolean | null, onProgress: TAURI_CHANNEL<ProgressUpdate>) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("compile_folder", { folderPath, autoServe, onProgress }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command to install macOS Finder integration for one-click compilation.
 * 
 * Creates an Automator workflow that adds "Publish to Web" to the Finder
 * context menu when right-clicking folders. This provides seamless integration
 * with the user's file management workflow.
 * 
 * # Installation Process
 * 1. Creates `~/Library/Services/Publish to Web.workflow` bundle
 * 2. Writes Info.plist with proper NSServices configuration
 * 3. Embeds shell script that triggers `moss://` deep links
 * 4. Registers with macOS Services for folder context menus
 * 
 * # Workflow Behavior
 * When users right-click a folder in Finder:
 * - "Publish to Web" appears in the context menu
 * - Clicking it URL-encodes the folder path
 * - Opens `moss://publish?path=<encoded_path>`
 * - Triggers the compilation workflow in this app
 * 
 * # Security
 * The generated shell script uses only built-in macOS commands:
 * - `printf` and `sed` for URL encoding
 * - `open` for deep link activation
 * - No external dependencies or network access
 * 
 * # Returns
 * * `Ok(String)` - Success message with installation location
 * * `Err(String)` - Error message with failure details
 * 
 * # Errors
 * * HOME environment variable not found
 * * Permission denied creating Services directory
 * * File write failures during installation
 * * Cannot remove existing workflow for reinstallation
 * 
 * # Platform Support
 * Currently macOS only. Uses Automator and NSServices APIs.
 * 
 * # Example
 * ```rust
 * let result = install_finder_integration()?;
 * // Returns: "Finder integration installed successfully! Right-click..."
 * ```
 */
async installFinderIntegration() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_finder_integration") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command to retrieve system diagnostic information.
 * 
 * Collects runtime information about the application's integration
 * with the operating system for debugging, support, and user feedback.
 * 
 * # Collected Information
 * * Operating system identification
 * * Tray icon visibility status
 * * Finder integration installation status (macOS)
 * * Application version from package metadata
 * 
 * # Arguments
 * * `app` - Tauri application handle for system access
 * 
 * # Returns
 * * `Ok(SystemInfo)` - Diagnostic information structure
 * * `Err(String)` - Error collecting system information
 * 
 * # macOS Integration
 * Checks for Automator workflow at:
 * `~/Library/Services/Publish to Web.workflow`
 * 
 * This indicates whether right-click folder compilation is available.
 */
async getSystemStatus() : Promise<Result<SystemInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_system_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Open preview window for a folder
 */
async openPreviewWindow(folderPath: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_preview_window", { folderPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Publish content from preview window to hosting platform
 * 
 * This handles the "Publish" step (upload to host), not the "Build" step.
 * The site should already be built and preview server running when this is called.
 */
async publishFromPreview(previewId: string, platform: string | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("publish_from_preview", { previewId, platform }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Open folder in system editor
 */
async openEditorFromPreview(previewId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_editor_from_preview", { previewId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Add syndication target to preview
 */
async addSyndicationTarget(previewId: string, target: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_syndication_target", { previewId, target }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Remove syndication target from preview
 */
async removeSyndicationTarget(previewId: string, target: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_syndication_target", { previewId, target }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Get preview window state
 */
async getPreviewState(previewId: string) : Promise<Result<PreviewState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_preview_state", { previewId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Close preview window
 */
async closePreviewWindowCmd(previewId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_preview_window_cmd", { previewId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command for folder compilation with GUI directory picker.
 * 
 * Provides a comprehensive workflow for folder compilation through the GUI:
 * 1. Temporarily switches to Regular activation policy for proper dialog display
 * 2. Shows native directory picker with remembered last location
 * 3. Compiles selected folder and starts preview server
 * 4. Opens preview window with publish/edit controls
 * 5. Manages activation policy for optimal UX
 * 
 * # Activation Policy Management
 * - Switches to Regular briefly for centered dialog display
 * - Stays in Regular while preview window is open
 * - Restores Accessory when no preview window (background operation)
 * 
 * # Arguments
 * * `app` - Tauri application handle for dialog and window management
 * 
 * # Returns
 * * `Ok(String)` - Success message with preview window status
 * * `Err(String)` - Error message (user cancellation, compilation failure, etc.)
 * 
 * # Error Handling
 * - User cancellation: Returns success with "canceled" message
 * - Compilation errors: Shows error dialog + restores Accessory mode
 * - Dialog timeout: Helpful message about bringing app to front
 * 
 * # Dialog Positioning
 * Uses both activation policy switching AND persistent dialog anchor window
 * for reliable dialog centering across different macOS system states.
 */
async compileWithDirectoryPicker() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("compile_with_directory_picker") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Setup GitHub repository and configure remote
 * 
 * Creates a new GitHub repository and configures it as the origin remote
 * for the project. This handles the "Connect to GitHub" button action.
 */
async setupGithubRepository(previewId: string, repoName: string, isPublic: boolean, githubToken: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("setup_github_repository", { previewId, repoName, isPublic, githubToken }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Tauri command: Refresh publish button state
 * 
 * Re-checks git configuration and updates the publish button state.
 * Useful after external git operations or manual git setup.
 */
async refreshPublishState(previewId: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("refresh_publish_state", { previewId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update the iframe source in the main window instead of creating separate preview windows
 */
async updateMainWindowPreview(previewUrl: string, folderPath: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_main_window_preview", { previewUrl, folderPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * Static site deployment configuration.
 * 
 * Specifies where and how the generated site should be published,
 * supporting multiple hosting providers and custom domains.
 */
export type DeploymentConfig = { 
/**
 * Hosting provider identifier ("moss.pub", "github", "netlify", etc.)
 */
provider: string; 
/**
 * Custom domain name for the published site
 */
custom_domain: string | null; 
/**
 * Whether to automatically republish when content changes
 */
auto_publish: boolean }
/**
 * Metadata for a single file discovered during folder scanning.
 * 
 * Contains essential information needed for static site generation,
 * including file type classification and modification timestamps.
 */
export type FileInfo = { 
/**
 * Relative path from the scanned root directory
 */
path: string; 
/**
 * File extension in lowercase (e.g., "md", "jpg", "html")
 */
file_type: string; 
/**
 * File size in bytes
 */
size: string; 
/**
 * Unix timestamp as string, if available
 */
modified: string | null }
/**
 * Information about a git remote, specifically GitHub remotes
 */
export type GitRemoteInfo = { 
/**
 * The remote URL (e.g., https://github.com/user/repo.git)
 */
url: string; 
/**
 * Whether this is a GitHub remote
 */
is_github: boolean; 
/**
 * Repository name extracted from URL
 */
repo_name: string; 
/**
 * Repository owner/organization
 */
owner: string }
/**
 * User configuration for site generation and publishing.
 * 
 * Contains site metadata, theme settings, and deployment preferences.
 * Can be stored in `.moss/config.toml` within project directories.
 */
export type MossConfig = { 
/**
 * Display name for the generated website
 */
site_name: string | null; 
/**
 * Author name for metadata and attribution
 */
author: string | null; 
/**
 * Theme identifier for styling the generated site
 */
theme: string | null; 
/**
 * Local directory for generated site files
 */
output_dir: string | null; 
/**
 * Base URL for absolute links (e.g., "<https://example.com>")
 */
base_url: string | null; 
/**
 * Deployment configuration settings
 */
deployment: DeploymentConfig }
/**
 * Parsed markdown document with frontmatter and content.
 * 
 * Represents a processed markdown file ready for HTML generation.
 * Enhanced data model following Jekyll/Hugo patterns for consistent site generation.
 * References:
 * - https://jekyllrb.com/docs/variables/
 * - https://gohugo.io/variables/page/
 */
export type ParsedDocument = { 
/**
 * Document title from frontmatter or filename
 */
title: string; 
/**
 * Raw markdown content without frontmatter
 */
content: string; 
/**
 * HTML content generated from markdown
 */
html_content: string; 
/**
 * Relative URL path for the generated page
 */
url_path: string; 
/**
 * Publication date if specified in frontmatter
 */
date: string | null; 
/**
 * Topics/categories from frontmatter
 */
topics: string[]; 
/**
 * Estimated reading time in minutes
 */
reading_time: number; 
/**
 * Excerpt or summary of the content
 */
excerpt: string; 
/**
 * URL-safe slug identifier (auto-generated from title/filename)
 * Following Hugo slug conventions
 */
slug: string; 
/**
 * Complete URL with depth-aware path generation
 * Following Jekyll permalink patterns
 */
permalink: string; 
/**
 * Preferred display title (H1 > frontmatter.title > filename)
 * Following Eleventy computed data patterns
 */
display_title: string }
/**
 * Metadata extracted from the preview content
 */
export type PreviewMetadata = { title: string | null; description: string | null; author: string | null; created_date: string | null }
/**
 * Represents the state of a preview window
 */
export type PreviewState = { 
/**
 * Port number of the running preview server
 */
server_port: number | null; 
/**
 * Path to the source folder being previewed
 */
folder_path: string; 
/**
 * Whether this content has been published
 */
is_published: boolean; 
/**
 * List of syndication targets (platforms where content is shared)
 */
syndication_targets: string[]; 
/**
 * Unique identifier for this preview session
 */
id: string; 
/**
 * Git remote information if available
 */
git_remote: GitRemoteInfo | null; 
/**
 * Current publish button state
 */
publish_button_state: PublishButtonState }
/**
 * Real-time progress update for compilation process.
 * 
 * Provides structured progress information for the frontend
 * to display during website compilation and server startup.
 */
export type ProgressUpdate = { 
/**
 * Current step being executed
 */
step: string; 
/**
 * Detailed message about current operation
 */
message: string; 
/**
 * Progress completion percentage (0-100)
 */
percentage: number; 
/**
 * Whether this step is completed
 */
completed: boolean; 
/**
 * Preview URL when server is ready (optional)
 */
url: string | null; 
/**
 * Preview server port when server is ready (optional)
 */
port: number | null }
/**
 * Complete analysis of a folder's contents for static site generation.
 * 
 * Contains categorized file listings and inferred project characteristics
 * used to determine the optimal site generation strategy.
 */
export type ProjectStructure = { 
/**
 * Absolute path to the scanned directory
 */
root_path: string; 
/**
 * Markdown and text files (.md, .markdown, etc.)
 */
markdown_files: FileInfo[]; 
/**
 * HTML files (.html, .htm)
 */
html_files: FileInfo[]; 
/**
 * Image files (.jpg, .png, .gif, .svg, etc.)
 */
image_files: FileInfo[]; 
/**
 * All other files including documents (.docx, .pages, etc.)
 */
other_files: FileInfo[]; 
/**
 * Total count of all discovered files
 */
total_files: string; 
/**
 * Inferred site structure type
 */
project_type: ProjectType; 
/**
 * Detected homepage file path, if any
 */
homepage_file: string | null; 
/**
 * Subdirectories containing document files
 */
content_folders: string[] }
/**
 * Website structure classification based on content organization patterns.
 * 
 * Automatically detected from folder structure to determine the most
 * appropriate static site generation strategy.
 */
export type ProjectType = 
/**
 * Site with homepage and organized content in subdirectories
 * (e.g., `/posts/`, `/projects/`, `/docs/`)
 */
"HomepageWithCollections" | 
/**
 * Small site with ≤5 document files, all suitable for main navigation
 */
"SimpleFlatSite" | 
/**
 * Large flat site with >5 files, requiring selective navigation menu
 */
"BlogStyleFlatSite"
/**
 * Represents the different states of the publish button
 */
export type PublishButtonState = 
/**
 * No git repository found - show "Setup Git"
 */
"SetupGit" | 
/**
 * Git repository exists but no GitHub remote - show "Connect to GitHub"
 */
"ConnectToGitHub" | 
/**
 * GitHub remote exists and ready to publish - show "Publish"
 */
"Publish" | 
/**
 * Content has been published - show "Published" with URL
 */
{ Published: string }
/**
 * Result of static site generation process.
 * 
 * Contains summary information about the generated site
 * including page count and output location.
 */
export type SiteResult = { 
/**
 * Number of HTML pages generated
 */
page_count: string; 
/**
 * Path to the generated site directory
 */
output_path: string; 
/**
 * Site metadata extracted from content
 */
site_title: string }
/**
 * System diagnostic information for debugging and user support.
 * 
 * Contains runtime information about the application's integration
 * with the operating system and current operational status.
 * Used by support commands and debugging workflows.
 */
export type SystemInfo = { 
/**
 * Operating system identifier (e.g., "macos", "windows", "linux")
 */
os: string; 
/**
 * Whether Finder integration is installed (macOS only)
 */
finder_integration: boolean; 
/**
 * Application version string from Cargo.toml
 */
app_version: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
