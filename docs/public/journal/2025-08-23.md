---
topics:
  - Testing
  - Architecture
  - Quality
---

# Testing What Matters

## The Problem We Faced

Our test suite had grown to 21 tests, all passing, giving the illusion of quality. But the app was brittle - small refactors broke tests, yet actual bugs slipped through. We were testing implementation details instead of user-facing behavior.

This created a development bottleneck: every code improvement required updating tests that validated internal mechanics rather than external promises. We needed to distinguish between tests that provide confidence and tests that provide busy work.

## The Question

"What would a user notice if this broke?"

That question eliminated most tests. Users don't see data structures. They don't count pixels in tray icons. They experience behavior: does the app start? Does right-click work? Does their folder become a website?

## What We Kept

Four tests that matter:

- **Tray icon appears** - User sees moss is running
- **Finder integration installs** - User can right-click folders
- **Content transforms correctly** - User gets expected output
- **URLs parse properly** - User's folder paths work

These test the contract with humans, not the contract with code.

## What We Learned

**Test behavior, not implementation**. If you can refactor the code without changing tests, you're testing the right things. If refactoring breaks tests, you're probably testing implementation details.

**False confidence is dangerous**. Tests that always pass teach nothing. Tests that can fail meaningfully teach everything.

**Quality over quantity**. Four good tests are worth more than 17 tests that check nothing important.

## Trade-offs Made

**Test Coverage vs Test Value**: We chose meaningful tests over comprehensive coverage. 4 behavior-focused tests provide more confidence than 21 implementation-detail tests.

**Maintenance vs Documentation**: We kept only tests that would naturally break when user-facing behavior changes, eliminating tests that break during healthy refactoring.

## Impact on Development

**Faster Iteration**: Refactoring no longer requires updating unrelated tests. Code improvement doesn't fight test maintenance.

**Real Confidence**: Test failures now indicate actual problems users would experience, not internal implementation changes.

**Clearer Boundaries**: The remaining tests define our contract with users, making it obvious what changes require careful consideration.

## Future Implications

This testing philosophy will guide all future development: when adding features, we'll ask "What user-facing behavior does this change?" and test only those boundaries.

It also establishes a principle for tool design: measure outcomes, not mechanics. This applies beyond testing to metrics, documentation, and API design.

---

_Technical references:_

- _[Growing Object-Oriented Software, Guided by Tests](http://www.growing-object-oriented-software.com/) - Behavioral testing philosophy and outside-in development_
- _[Testing implementation vs behavior](../../.claude/CLAUDE.md#test-user-behavior-not-implementation-details) - Our testing guidelines for user contract validation_
